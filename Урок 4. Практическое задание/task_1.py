"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""
import timeit
import random

# равенство: 1+2+...+n =
# Цикл
n = 100

def cycle(n):
    i = 1
    cal_1 = 0
    while i <= n:
        cal_1 += i
        i += 1
    return cal_1

# Рекурсия
def cal1_recur(N):
    if N == 1:
        return N
    elif N > 0:
        return N + cal1_recur(N - 1)

print(timeit.timeit("cycle(n)", setup="from __main__ import cycle, n", number=1000))
print(timeit.timeit("cal1_recur(n)", setup="from __main__ import cal1_recur, n", number=1000))

# n = 100
#cycle(n) - 0.011740400000000005: быстродействие функции прямо пропорционально
# входному значению n; чем больше n, тем больше итераций цикла
#cal1_recur(n) -  0.030192599999999993: быстродействие функции прямо пропорционально
# входному значению n; чем больше n, тем больше раз функция вызовет сама себя

# Скорость работы обоих алгоритмов на заданных данных практически одинакова.


# В одномерном массиве целых чисел определить два наименьших элемента.
# Они могут быть как равны между собой (оба являться минимальными), так и различаться.

A = [random.randint(1, 100) for i in range(1000)]
print(f'Массив: {A}')

def min_1(A):
    MIN_1 = A[0]
    MIN_2 = A[0]
    for i in A:
        if i < MIN_1:
            MIN_2 = MIN_1
            MIN_1 = i
        elif i < MIN_2:
            MIN_2 = i
    return f'Наименьший элемент: {MIN_1}, Второй наименьший элемент: {MIN_2}'

def min_2(A):
    B = sorted(A)[:2]
    return f'Наименьший элемент: {B[0]}, Второй наименьший элемент: {B[1]}'

print(timeit.timeit("min_1(A)", setup="from __main__ import min_1, A", number=1000))
print(timeit.timeit("min_2(A)", setup="from __main__ import min_2, A", number=1000))

# Массив: len(A)= 10
# min_1(A) - 0.0014502999999999946
# min_2(A) - 0.0010322999999999999

# Массив: len(A) = 100
# min_1(A) - 0.014599399999999998
# min_2(A) - 0.0065578999999999985

# Массив: len(A) = 1000
# min_1(A) - 0.1080166
# min_2(A) -  0.1781655

# При длинне массива 10 и 100 быстрее выполняется функция со встроенной сортировкой и срезом,
# но при увеличении длинны массива до 1000, эффективней работает функция с итерацией
